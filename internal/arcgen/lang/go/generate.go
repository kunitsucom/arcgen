package arcgengo

import (
	"bytes"
	"context"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"os"
	"reflect"
	"strconv"
	"strings"

	errorz "github.com/kunitsucom/util.go/errors"
	filepathz "github.com/kunitsucom/util.go/path/filepath"

	"github.com/kunitsucom/arcgen/internal/arcgen/lang/util"
	"github.com/kunitsucom/arcgen/internal/config"
)

//nolint:cyclop
func Generate(ctx context.Context, src string) error {
	arcSrcSets, err := parse(ctx, src)
	if err != nil {
		return errorz.Errorf("parse: %w", err)
	}

	newFile := token.NewFileSet()

	for _, arcSrcSet := range arcSrcSets {
		for _, arcSrc := range arcSrcSet {
			filePrefix := strings.TrimSuffix(arcSrc.Position.Filename, fileSuffix)
			filename := fmt.Sprintf("%s.%s.gen%s", filePrefix, config.ColumnTagGo(), fileSuffix)
			f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o644)
			if err != nil {
				return errorz.Errorf("os.Open: %w", err)
			}

			packageName := arcSrc.Package.Name
			structName := arcSrc.TypeSpec.Name.Name
			tableName := extractTableNameFromCommentGroup(arcSrc.CommentGroup)
			columnNames := func() []string {
				columnNames := make([]string, 0)
				for _, field := range arcSrc.StructType.Fields.List {
					if field.Tag != nil {
						tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
						switch columnName := tag.Get(config.ColumnTagGo()); columnName {
						case "", "-":
							// noop
						default:
							columnNames = append(columnNames, columnName)
						}
					}
				}
				return columnNames
			}()

			node := generateASTFile(packageName, structName, tableName, config.MethodPrefixGlobal(), config.MethodPrefixColumn(), columnNames)

			buf := bytes.NewBuffer(nil)
			if err := format.Node(buf, newFile, node); err != nil {
				return errorz.Errorf("format.Node: %w", err)
			}

			// add header comment
			s := strings.Replace(
				buf.String(),
				"package "+packageName+"\n",
				fmt.Sprintf("// Code generated by arcgen. DO NOT EDIT.\n//\n// source: %s:%d\n\npackage "+packageName+"\n", filepathz.Short(arcSrc.Position.Filename), arcSrc.Position.Line),
				1,
			)
			// add blank line between methods
			s = strings.ReplaceAll(s, "\n}\nfunc ", "\n}\n\nfunc ")

			// write to file
			if _, err := f.WriteString(s); err != nil {
				return errorz.Errorf("f.WriteString: %w", err)
			}
		}
	}

	return nil
}

func extractTableNameFromCommentGroup(commentGroup *ast.CommentGroup) string {
	for _, comment := range commentGroup.List {
		if matches := util.RegexIndexTableName.Regex.FindStringSubmatch(comment.Text); len(matches) > util.RegexIndexTableName.Index {
			return matches[util.RegexIndexTableName.Index]
		}
	}
	return fmt.Sprintf("ERROR: TABLE NAME IN COMMENT `// \"%s\": table: *` NOT FOUND: comment=%q", config.ColumnTagGo(), commentGroup.Text())
}

//nolint:funlen
func generateASTFile(packageName string, structName string, tableName string, prefixGlobal string, prefixColumn string, columnNames []string) *ast.File {
	file := &ast.File{
		// package
		Name: &ast.Ident{
			Name: packageName,
		},
		// methods
		Decls: []ast.Decl{
			&ast.FuncDecl{
				Recv: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{
								{
									Name: "s",
								},
							},
							Type: &ast.StarExpr{
								X: &ast.Ident{
									Name: structName, // MEMO: struct name
								},
							},
						},
					},
				},
				Name: &ast.Ident{
					Name: prefixGlobal + "TableName",
				},
				Type: &ast.FuncType{
					Params: &ast.FieldList{},
					Results: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.Ident{
									Name: "string",
								},
							},
						},
					},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ReturnStmt{
							Results: []ast.Expr{
								&ast.Ident{
									Name: strconv.Quote(tableName),
								},
							},
						},
					},
				},
			},
		},
	}

	file.Decls = append(file.Decls, generateASTColumnMethods(structName, prefixGlobal, prefixColumn, columnNames)...)

	return file
}

//nolint:funlen
func generateASTColumnMethods(structName string, prefixGlobal string, prefixColumn string, columnNames []string) []ast.Decl {
	decls := make([]ast.Decl, 0)

	// all column names method
	elts := make([]ast.Expr, 0)
	for _, columnName := range columnNames {
		elts = append(elts, &ast.BasicLit{
			Kind:  token.STRING,
			Value: strconv.Quote(columnName),
		})
	}
	decls = append(decls, &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{
							Name: "s",
						},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{
							Name: structName, // MEMO: struct name
						},
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: prefixGlobal + "ColumnNames",
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.Ident{
							Name: "[]string",
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CompositeLit{
							Type: &ast.ArrayType{
								Elt: &ast.Ident{
									Name: "string",
								},
							},
							Elts: elts,
						},
					},
				},
			},
		},
	})

	// each column name methods
	for _, columnName := range columnNames {
		decls = append(decls, &ast.FuncDecl{
			Recv: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							{
								Name: "s",
							},
						},
						Type: &ast.StarExpr{
							X: &ast.Ident{
								Name: structName, // MEMO: struct name
							},
						},
					},
				},
			},
			Name: &ast.Ident{
				Name: prefixGlobal + prefixColumn + columnName,
			},
			Type: &ast.FuncType{
				Params: &ast.FieldList{},
				Results: &ast.FieldList{
					List: []*ast.Field{
						{
							Type: &ast.Ident{
								Name: "string",
							},
						},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.Ident{
								Name: strconv.Quote(columnName),
							},
						},
					},
				},
			},
		})
	}

	return decls
}
