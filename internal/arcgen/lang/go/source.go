package arcgengo

import (
	"fmt"
	"go/ast"
	"go/token"
	"reflect"
	"regexp"
	"strings"
	"sync"

	filepathz "github.com/kunitsucom/util.go/path/filepath"

	"github.com/kunitsucom/arcgen/internal/arcgen/lang/util"
	"github.com/kunitsucom/arcgen/internal/config"
	"github.com/kunitsucom/arcgen/internal/logs"
)

type (
	ARCSource struct {
		// Source for sorting
		Source token.Position
		// TypeSpec is used to guess the table name if the CREATE TABLE annotation is not found.
		TypeSpec *ast.TypeSpec
		// StructType is used to determine the column name. If the tag specified by --go-column-tag is not found, the field name is used.
		StructType   *ast.StructType
		CommentGroup *ast.CommentGroup
	}
	ARCSourceSet struct {
		Source         token.Position
		Filename       string
		PackageName    string
		ARCSourceSlice []*ARCSource
	}
	ARCSourceSetSlice []*ARCSourceSet
)

//nolint:gochecknoglobals
var (
	_GoColumnTagCommentLineRegex     *regexp.Regexp
	_GoColumnTagCommentLineRegexOnce sync.Once
)

const (
	//	                                             _____________ <- 1. comment prefix
	//	                                                             __ <- 2. tag name
	//	                                                                               ___ <- 4. comment suffix
	_GoColumnTagCommentLineRegexFormat       = `^\s*(//+\s*|/\*\s*)?(%s)\s*:\s*(.*)\s*(\*/)?`
	_GoColumnTagCommentLineRegexContentIndex = /*                               ^^ 3. tag value */ 3
)

func GoColumnTagCommentLineRegex() *regexp.Regexp {
	_GoColumnTagCommentLineRegexOnce.Do(func() {
		_GoColumnTagCommentLineRegex = regexp.MustCompile(fmt.Sprintf(_GoColumnTagCommentLineRegexFormat, config.GoColumnTag()))
	})
	return _GoColumnTagCommentLineRegex
}

func (a *ARCSource) extractStructName() string {
	return a.TypeSpec.Name.Name
}

func (a *ARCSource) extractTableNameFromCommentGroup() string {
	if a.CommentGroup != nil {
		for _, comment := range a.CommentGroup.List {
			if matches := util.RegexIndexTableName.Regex.FindStringSubmatch(comment.Text); len(matches) > util.RegexIndexTableName.Index {
				return strings.Trim(strings.Trim(strings.Trim(matches[util.RegexIndexTableName.Index], "`"), `"`), "'")
			}
		}
	}

	logs.Debug.Printf("WARN: table name in comment not found: `// \"%s\": table: *`: comment=%q", config.GoColumnTag(), a.CommentGroup.Text())
	return ""
}

func (a *ARCSource) extractFieldNamesAndColumnNames() ([]string, []string) {
	fieldNames, columnNames := make([]string, 0, len(a.StructType.Fields.List)), make([]string, 0, len(a.StructType.Fields.List))
	for _, field := range a.StructType.Fields.List {
		if field.Tag != nil {
			tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
			switch columnName := tag.Get(config.GoColumnTag()); columnName {
			case "", "-":
				logs.Trace.Printf("SKIP: %s: field.Names=%s, columnName=%q", a.Source.String(), field.Names, columnName)
				// noop
			default:
				logs.Trace.Printf("%s: field.Names=%s, columnName=%q", a.Source.String(), field.Names, columnName)
				fieldNames, columnNames = append(fieldNames, field.Names[0].Name), append(columnNames, columnName)
			}
		}
	}

	return fieldNames, columnNames
}

func (ss *ARCSourceSet) generateGoFileHeader() string {
	return generateGoFileHeader() +
		"// source: " + filepathz.Short(ss.Source.Filename) + "\n"
}

func generateGoFileHeader() string {
	return "" +
		"// Code generated by arcgen. DO NOT EDIT." + "\n" +
		"//" + "\n"
}
